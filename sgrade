#!/usr/bin/env sh
#
# sgrade - Simple alternative to topgrade.

# Concatenates the status of all the updates in the variable $status
# and executes retry() when the command failed $2
# and doesn't have a reason $3 to fail
status () {
    if [ -z "$3" ] && [ "$2" = "XX" ]; then
        retry $1
    fi
    status="$status$1 $2!  $3\n"
}

retry () {
    printf "Retry? (y)es/(N)o/(q)uit? "
    read answer
    if [ "$answer" != "${answer#[Yy]}" ]; then
        update_$1
    elif [ "$answer" != "${answer#[Qq]}" ]; then
        exit 0
    fi
}

help () {
    cat <<EOF
${0##*/}            update
${0##*/} -d         show stderr (debug mode)
${0##*/} -h --help  show help
EOF
exit 0
}

heading () {
    set +x
    echo
    cols=$(tput cols)
    center=$((cols/2))
    header="$1"
    headersize="${#header}"
    indent=$((center-(headersize/2)))
    meio=0

    i=0
    while [ $i -lt $cols ]; do
        if [ $i -lt $indent ]; then
            col="${col}─"
        elif [ $i -gt $((indent+2+headersize)) ]; then
            col="${col}─"
        elif [ $meio = 0 ]; then
            col="${col} $header "
            meio=1
        fi

        i=$((i+1))
    done

    echo "$col"
    col=""
    echo
    $SG_DEBUG && set -x
}

# This is just a simple wrapper around 'command -v' to avoid
# spamming '>/dev/null' throughout this function. This also guards
# against aliases and functions.
has () {
    _cmd=$(command -v "$1") 2>/dev/null || return 1
    [ -x "$_cmd" ] || return 1
}

as_su () {
    eval su root -c \'"$*"\'
}

update_sgrade () {
    heading SGRADE
    if has git; then
        [ -z "$SG_PATH" ] && SG_PATH="${XDG_DATA_HOME:-$HOME/.local/share}/sgrade"
        if [ ! -d "$SG_PATH" ]; then
            git clone https://github.com/lucastavaresa/sgrade $SG_PATH
        fi

        current_path=$(pwd)

        cd $SG_PATH && git pull --rebase

        cd $current_path

        sg_repo_bin="$SG_PATH/sgrade"
        sg_bin="$(whereis sgrade | cut -d' ' -f 2)"
        if [ -z "$sg_bin" ] || [ ! -e "$sg_bin" ]; then
            if echo $PATH | grep ${XDG_BIN_HOME:-$HOME/.local/bin}; then
                sg_bin="${XDG_BIN_HOME:-$HOME/.local/bin}/sgrade"
            else
                sg_bin="/usr/local/bin"
            fi
        fi

        sg_diff_file="${XDG_CACHE_HOME:-$HOME/.cache}/sg_diff.diff"
        diff -N $sg_bin $sg_repo_bin > $sg_diff_file

        if [ ! -z "$(cat $sg_diff_file)" ]; then
            printf "There is a new sgrade file, want to see the difference [Y/n]? "
            read answer
            if [ "$answer" = "${answer#[Nn]}" ]; then
                ${VISUAL:-$EDITOR} $sg_diff_file
            fi

            printf "This will place the new sgrade in $sg_bin, \
do you want to update/install [y/N]? "
                read answer
                if [ "$answer" != "${answer#[Yy]}" ]; then
                    echo $sg_bin | grep $HOME && cp $sg_repo_bin $sg_bin || $SU cp $sg_repo_bin $sg_bin
                    echo
                    echo "You have to re-execute after updates!"
                    exit 0
                else
                    status sgrade XX "You refused to update sgrade!"
                fi
        fi
    else
        status sgrade XX "You need git to update sgrade automatically!"
    fi
}

update_packages () {
    heading PACKAGES
    if has paru; then
        paru -Pw
        paru --color always -Syu && status packages OK || status packages XX
    elif has yay; then
        yay -Pw
        yay --color always -Syu && status packages OK || status packages XX
    elif has pacman; then
        $SU pacman --color always -Syu && status packages OK || status packages XX
    elif has xbps-install; then
        $SU xbps-install -Su && status packages OK || status packages XX
    elif has apt; then
        $SU apt update && $SU apt dist-upgrade && status packages OK || status packages XX
    elif has dnf; then
        $SU dnf upgrade && status packages OK || status packages XX
    elif has yum; then
        $SU yum upgrade && status packages OK || status packages XX
    elif has swupd; then
        $SU swupd update && status packages OK || status packages XX
    elif has zypper; then
        $SU zypper refresh && $SU zypper dist-upgrade && status packages OK || status packages XX
    elif has pkg; then
        $SU pkg upgrade && status packages OK || status packages XX
        $SU pkg audit -Fr
        update_freebsd
    elif has pkg_add; then
        $SU pkg_add -u && status packages OK || status packages XX
        update_openbsd
    elif has pkgin; then
        $SU pkgin upgrade && status packages OK || status packages XX
    fi
}

update_freebsd () {
    if has freebsd-update; then
        heading FREEBSD
        $SU freebsd-update fetch install && status freebsd OK || status freebsd XX
    fi
}

update_openbsd () {
    if has sysupgrade; then
        heading OPENBSD
        $SU sysupgrade -n && status packages OK || status packages XX
    fi
}

update_etc () {
    if has pacdiff; then
        heading ETC
        $SU pacdiff && status etc OK || status etc XX
    fi
}

update_nodejs () {
    if has node; then
        if has yarn; then
            heading YARN
            yarn global update && status nodejs OK || status nodejs XX
        elif has npm; then
            heading NPM
            if npm root --location=global | grep $HOME; then
                npm update --location=global && status nodejs OK || status nodejs XX
            fi
        else
            status nodejs XX "Install yarn or npm!"
        fi
    fi
}

update_pip () {
    if has pip; then
        heading PIP
        pip install $(pip freeze | sed 's/==/>=/;/.*@.*$/d') --upgrade && status pip OK || status pip XX
    fi
}

update_dotnet () {
    if has dotnet; then
        heading DOTNET
        to_update="$(dotnet tool list --global | sed '1,2d;s/ .*//')"
        if [ ! -z "$to_update" ]; then
            dotnet tool update $to_update --global && status dotnet OK || status dotnet XX
        else
            status dotnet OK "No dotnet packages!"
        fi
    fi
}

update_fish () {
    if has fish; then
        if [ -e "${XDG_CONFIG_HOME:-$HOME/.config}/fish/functions/fisher.fish" ]; then
            heading FISHER
            fish -c "fisher update" && status fisher OK || status fisher XX
        elif [ -d "${XDG_CONFIG_HOME:-$HOME/.config}/fundle" ]; then
            heading FUNDLE
            fish -c "fundle self-update && fundle update" && status fundle OK || status fundle XX
        fi
    fi
}

update_rustup () {
    if has rustup; then
        heading RUSTUP
        if whereis rustup | cut -d' ' -f 2 | grep $HOME; then
            rustup self-update && status rustup OK || status rustup XX
        else
            rustup update && status rustup OK || status rustup XX
        fi
    fi
}

update_cargo () {
    if has cargo; then
        heading CARGO
        if has cargo-install-update; then
            cargo install-update -g -a && status cargo OK || status cargo XX
        else
            status cargo XX "Install cargo-update!"
        fi
    fi
}

update_flatpak () {
    if has flatpak; then
        heading FLATPAK
        flatpak update && status flatpak OK || status flatpak XX
    fi
}

update_snap () {
    if has snap; then
        heading SNAP
        $SU snap refresh && status snap OK || status snap XX
    fi
}

update_brew () {
    if has brew; then
        heading BREW
        brew update && brew upgrade && status brew OK || status brew XX
    fi
}

update_nix () {
    if has nix; then
        heading NIX
        nix upgrade-nix && nix --upgrade && status nix OK || status nix XX
    fi
}

update_pearl () {
    if has pearl; then
        heading PEARL
        pearl update && status pearl OK || status pearl XX
    fi
}

update_gem () {
    if has gem; then
        heading GEM
        if [ -d "$HOME/.gem" ]; then
            gem upgrade --user-install && status gem OK || status gem XX
        else
            gem upgrade && status gem OK || status gem XX
        fi
    fi
}

update_gh () {
    if has gh; then
        heading GH
        gh extension upgrade --all
    fi
}

update_distrobox () {
    if has distrobox; then
        heading DISTROBOX
        distrobox upgrade --all
    fi
}

update_custom () {
    if [ -e ${XDG_CONFIG_HOME:-$HOME/.config}/sgrade/custom ]; then
        heading CUSTOM
        ${XDG_CONFIG_HOME:-$HOME/.config}/sgrade/custom && status custom OK || status custom XX
    fi
}

main() {
    SG_DEBUG=false
    case $* in
        -d) SG_DEBUG=true ;;
        -h) help ;;
        --help) help ;;
    esac

    if has doas; then
        SU=doas
    elif has sudo; then
        SU=sudo
    else
        SU=as_su
    fi

    status=""
    # Allow the user to specify the order and inclusion of information
    # functions through the 'SG_RESOURCES' environment variable.
    # shellcheck disable=2086
    {
        # Disable globbing and set the positional parameters to the
        # contents of 'SG_RESOURCES'.
        set -f
        set +f -- ${SG_RESOURCES-sgrade packages etc nodejs pip dotnet fish rustup cargo flatpak snap brew nix pearl gem gh distrobox custom}

        # Iterate over the above list and run any existing "update_" functions.
        for resource do
            "update_$resource"
        done
    }

    heading RESULTS
    echo "$status"
}

main "$@"
